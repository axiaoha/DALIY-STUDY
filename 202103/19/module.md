### 概述

CommonJS：服务器模块加载方案，运行时确定模块的依赖关系，生成一个对象
AMD：浏览器模块加载方案，运行时确定模块的依赖关系
ES6 模块：浏览器和服务器通用的模块解决方案，编译时确定模块的依赖关系，通过 export 命令显式指定输出的代码，再通过 import 命令输入

### 严格模式

- 变量必须声明后再使用

- 函数的参数不能有同名属性，否则报错

- 不能使用 with 语句

- 不能对只读属性赋值，否则报错

- 不能使用前缀 0 表示八进制数，否则报错

- 不能删除不可删除的属性，否则报错

- 不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]

- eval 不会在它的外层作用域引入变量

- eval 和 arguments 不能被重新赋值

- arguments 不会自动反映函数参数的变化

- 不能使用 arguments.callee

- 不能使用 arguments.caller

- 禁止 this 指向全局对象

- 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈

- 增加了保留字（比如 protected、static 和 interface）

### export 命令

export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名

export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。

export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。

export 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错

### import 命令

import 命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。如果 a 是一个对象，改写 a 的属性是允许的，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。

import 命令具有提升效果，会提升到整个模块的头部，首先执行。

由于 import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。

如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。

CommonJS 模块的 require 命令和 ES6 模块的 import 命令，可以写在同一个模块里面，但是最好不要这样做。因为 import 在静态解析阶段执行，所以它是一个模块之中最早执行的。

### 模块的整体加载

除了指定加载某个输出值，还可以使用整体加载，即用星号（\*）指定一个对象，所有输出值都加载在这个对象上面。

### export default 命令

export default 命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此 export default 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能唯一对应 export default 命令。

### export 与 import 的复合写法

如果在一个模块之中，先输入后输出同一个模块，import 语句可以与 export 语句写在一起。写成一行以后，foo 和 bar 实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用 foo 和 bar。

```js
export { foo, bar } from "my_module";

// 可以简单理解为
import { foo, bar } from "my_module";
export { foo, bar };
```

### 模块的继承

### 跨模块常量

这个项目常用

### import()

引入 import()函数，支持动态加载模块

import()类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载。

### 面试题

##### CommonJS、AMD、ES6 模块模块化的区别

##### js 的编译时与运行时

##### export 和 export defalut 的区别
