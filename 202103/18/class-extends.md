### 简介

子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。（子类实例的构建，基于父类实例）

如果子类没有定义 constructor 方法，这个方法会被默认添加,不管有没有显式定义，任何一个子类都有 constructor 方法。

### Object.getPrototypeOf()

用于判断一个类是否继承了另一个类

### super 关键字

super 这个关键字，既可以当作函数使用，也可以当作对象使用

对象总是继承其他对象的，所以可以在任意一个对象中，使用 super 关键字。

**super 作为函数调用时**

代表父类的构造函数。子类的构造函数必须执行一次 super 函数。

super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B 的实例，因此 super()在这里相当于 A.prototype.constructor.call(this)。

super()只能用在子类的构造函数之中，用在其他地方就会报错。

**super 作为对象时**

在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。

在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类实例。实际上执行的是 super.fnname.call(this)

通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性

如果 super 作为对象，用在静态方法之中，这时 super 将指向父类，而不是父类的原型对象。

在子类的静态方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例。

super.valueOf()返回的是一个子类的实例

### 类的 prototype 属性和**proto**属性

### 原生构造函数的继承

### Mixin 模式的实现

Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。

### 面试题

##### es5 继承与 es6 继承的区别

ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。

##### mixin

##### ES6 里 Class 的 Extends 继承原理
