`this`的5种绑定方式：

- 默认绑定(非严格模式下this指向全局对象, 严格模式下`this`会绑定到`undefined`)

- 隐式绑定(当函数引用有**上下文对象**时, 如 `obj.foo()`的调用方式, `foo`内的`this`指向`obj`)

- 显示绑定(通过`call()`或者`apply()`方法直接指定`this`的绑定对象, 如`foo.call(obj)`)

- new绑定

- 箭头函数绑定(`this`的指向由外层作用域决定的)

- [x] 默认绑定
  
  - 在非严格模式下`this`指向的是全局对象`window`，而在严格模式下会绑定到`undefined`。
  
  - 开启了严格模式，只是说使得函数内的`this`指向`undefined`，它并不会改变全局中`this`的指向(还是指向window对象)
  
  - 开启了严格模式，也不会阻止var声明的变量被绑定到`window`对象上。
  
  - 把`var`改成了`let 或者 const`，变量不会被绑定到`window`上
  
- [x] 隐式绑定

  this 永远指向最后调用它的那个对象

- [x] 隐式绑定的隐式丢失问题

  有两种情况容易发生隐式丢失问题：

  - 使用另一个变量来给函数取别名(这个和函数调用有关，this的指向是在函数调用的时候确认的)
  - 将函数作为参数传递时会被隐式赋值，回调函数丢失this绑定(如果你把一个函数当成参数传递到另一个函数的时候，也会发生隐式丢失的问题，且与包裹着它的函数的this指向无关。在非严格模式下，会把该函数的this绑定到window上，严格模式下绑定到undefined。)------setTimeoutd的第一个参数的this指向问题setTimeout(f)与setTimeout(()=>{f()})this指向的区别

- [x] 显式绑定

- [x] 显式绑定的其它用法`this` 永远指向最后调用它的那个对象

  - 匿名函数的`this`永远指向`window`

  - 使用`.call()`或者`.apply()`的函数是会直接执行的

  - `bind()`是创建一个新的函数，需要手动调用才会执行

  - 如果`call、apply、bind`接收到的第一个参数是空或者`null、undefined`的话，则会忽略这个参数

  - `forEach、map、filter`函数的第二个参数也是能显式绑定`this`的

- [x] new 绑定

- [x] 箭头函数绑定

  - 它里面的`this`是由外层作用域来决定的，且指向函数定义时的`this`而非执行时

  - 字面量创建的对象，作用域是`window`，如果里面有箭头函数属性的话，`this`指向的是`window`

  - 构造函数创建的对象，作用域是可以理解为是这个构造函数，且这个构造函数的`this`是指向新建的对象的，因此`this`指向这个对象。

  - 箭头函数的`this`是无法通过`bind、call、apply`来**直接**修改，但是可以通过改变作用域中`this`的指向来间接修改。
  - 避免使用箭头函数的场景：对象的方法、原型方法、构造函数、事件的回调函数

- [x] 综合题

- [x] 几道手写题（32道编程题）